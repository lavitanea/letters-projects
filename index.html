<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualising Words</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: #fafaf8;
            overflow: hidden;
            height: 100vh;
        }

        #title {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            color: #8b7355;
            letter-spacing: 3px;
            z-index: 1000;
            text-transform: lowercase;
            font-weight: 300;
        }

        #clear-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            padding: 12px 28px;
            background: #d4a5a5;
            border: none;
            border-radius: 25px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s;
            letter-spacing: 1px;
            text-transform: lowercase;
        }

        #clear-btn:hover {
            background: #c49090;
            transform: scale(1.05);
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .flower {
            position: absolute;
            transform-origin: center;
            transition: opacity 0.8s;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% {
                transform: translate(0, 0) rotate(0deg);
            }
            25% {
                transform: translate(3px, -5px) rotate(2deg);
            }
            50% {
                transform: translate(-2px, -8px) rotate(-2deg);
            }
            75% {
                transform: translate(-4px, -3px) rotate(1deg);
            }
        }

        .falling {
            animation: fall 2s forwards !important;
        }

        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="title">visualising words</div>
    <svg id="canvas"></svg>
    <button id="clear-btn">clear</button>

    <script>
        const canvas = document.getElementById('canvas');
        const clearBtn = document.getElementById('clear-btn');
        
        const vowels = ['a', 'e', 'i', 'o', 'u', 'y'];
        const consonants = 'bcdfghjklmnpqrstvwxz'.split('');
        
        // Pastel flower colors for each vowel
        const vowelColors = {
            'a': { pastel: '#ffd4d8', vibrant: '#ff6b7a' },
            'e': { pastel: '#ffe0eb', vibrant: '#ff8fb8' },
            'i': { pastel: '#d4e7ff', vibrant: '#6bb8ff' },
            'o': { pastel: '#ebd4ff', vibrant: '#c76bff' },
            'u': { pastel: '#dcd4ff', vibrant: '#9d6bff' },
            'y': { pastel: '#e8deff', vibrant: '#b89dff' }
        };

        let branches = [];
        let flowers = [];
        let lastTypeTime = Date.now();
        let typeSpeed = 0;
        let mainBranches = [];
        let flowerPositions = []; // Track flower positions for overlap checking

        function calculateTypeSpeed() {
            const now = Date.now();
            const timeDiff = now - lastTypeTime;
            typeSpeed = Math.max(0, Math.min(1, 1 - (timeDiff / 800)));
            lastTypeTime = now;
        }

        function initMainBranches() {
            if (mainBranches.length > 0) return;
            
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            
            const corners = [
                { x: 80, y: 120, angle: Math.atan2(centerY - 120, centerX - 80) },
                { x: window.innerWidth - 80, y: 120, angle: Math.atan2(centerY - 120, centerX - (window.innerWidth - 80)) },
                { x: window.innerWidth - 80, y: window.innerHeight - 80, angle: Math.atan2(centerY - (window.innerHeight - 80), centerX - (window.innerWidth - 80)) },
                { x: 80, y: window.innerHeight - 80, angle: Math.atan2(centerY - (window.innerHeight - 80), centerX - 80) }
            ];
            
            corners.forEach((corner, index) => {
                const distance = Math.hypot(centerX - corner.x, centerY - corner.y);
                const length = distance * 0.6;
                const endX = corner.x + Math.cos(corner.angle) * length;
                const endY = corner.y + Math.sin(corner.angle) * length;
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const controlX = corner.x + Math.cos(corner.angle) * length * 0.5;
                const controlY = corner.y + Math.sin(corner.angle) * length * 0.5;
                
                path.setAttribute('d', `M ${corner.x} ${corner.y} Q ${controlX} ${controlY} ${endX} ${endY}`);
                path.setAttribute('stroke', '#a89080');
                path.setAttribute('stroke-width', '8');
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('opacity', '0.6');
                
                canvas.appendChild(path);
                
                mainBranches.push({
                    element: path,
                    startX: corner.x,
                    startY: corner.y,
                    endX: endX,
                    endY: endY,
                    angle: corner.angle,
                    length: length
                });
            });
        }

        function getRandomPointOnMainBranch(branchIndex) {
            const branch = mainBranches[branchIndex];
            const t = 0.3 + Math.random() * 0.5;
            
            const x = branch.startX + (branch.endX - branch.startX) * t;
            const y = branch.startY + (branch.endY - branch.startY) * t;
            
            return { x, y, angle: branch.angle };
        }

        function createBranch(startX, startY, baseAngle, speed) {
            const angleVariation = (Math.random() - 0.5) * Math.PI / 2;
            const angle = baseAngle + angleVariation;
            const length = 30 + Math.random() * 30 + speed * 40;
            
            const endX = startX + Math.cos(angle) * length;
            const endY = startY + Math.sin(angle) * length;
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            // Sharp or curved based on speed
            if (speed > 0.5) {
                path.setAttribute('d', `M ${startX} ${startY} L ${endX} ${endY}`);
            } else {
                const controlX = startX + Math.cos(angle + 0.2) * length * 0.6;
                const controlY = startY + Math.sin(angle + 0.2) * length * 0.6;
                path.setAttribute('d', `M ${startX} ${startY} Q ${controlX} ${controlY} ${endX} ${endY}`);
            }
            
            // Color and thickness based on speed
            let color, strokeWidth, opacity;
            
            if (speed > 0.5) {
                // Fast: black, thick, solid
                const darkness = Math.floor((1 - speed) * 50);
                color = `rgb(${darkness}, ${darkness}, ${darkness})`;
                strokeWidth = 6 + speed * 8; // Up to 14px thick
                opacity = 1;
            } else {
                // Slow: light brown, thinner, transparent
                color = '#c4a895';
                strokeWidth = 3 + speed * 3; // 3-6px
                opacity = 0.3 + speed * 0.3; // 30-60%
            }
            
            path.setAttribute('stroke', color);
            path.setAttribute('stroke-width', strokeWidth);
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke-linecap', 'round');
            path.setAttribute('opacity', opacity);
            
            canvas.appendChild(path);
            branches.push({ element: path, endX, endY, angle });
            
            return { x: endX, y: endY };
        }

        function checkOverlap(x, y, size) {
            let overlapCount = 0;
            const checkRadius = size * 1.5;
            
            for (let pos of flowerPositions) {
                const distance = Math.hypot(x - pos.x, y - pos.y);
                if (distance < (checkRadius + pos.size)) {
                    overlapCount++;
                }
            }
            
            return overlapCount;
        }

        function findNonOverlappingPosition(baseX, baseY, size, maxAttempts = 20) {
            for (let i = 0; i < maxAttempts; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 40 + Math.random() * 60;
                const x = baseX + Math.cos(angle) * distance;
                const y = baseY + Math.sin(angle) * distance;
                
                // Keep within bounds
                if (x < 50 || x > window.innerWidth - 50 || y < 100 || y > window.innerHeight - 50) {
                    continue;
                }
                
                const overlaps = checkOverlap(x, y, size);
                const maxAllowedOverlaps = Math.floor(flowerPositions.length * 0.3);
                
                if (overlaps <= maxAllowedOverlaps) {
                    return { x, y };
                }
            }
            // If no good position found, return original
            return { x: baseX, y: baseY };
        }

        function createFlower(x, y, vowel, speed) {
            const colors = vowelColors[vowel];
            const petalCount = 6;
            
            // Dramatic size difference
            const baseSize = speed > 0.5 ? 20 + speed * 40 : 15; // Fast: much bigger
            const size = baseSize;
            
            // Check for overlap and adjust position
            const position = findNonOverlappingPosition(x, y, size);
            x = position.x;
            y = position.y;
            
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('class', 'flower');
            
            // Opacity: dramatic difference
            const opacity = speed > 0.5 ? 0.9 + speed * 0.1 : 0.25 + speed * 0.25; // Slow: 25-50%, Fast: 90-100%
            
            // Color choice
            const color = speed > 0.5 ? colors.vibrant : colors.pastel;
            
            // Create petals
            for (let i = 0; i < petalCount; i++) {
                const angle = (i * 360 / petalCount) * Math.PI / 180;
                
                if (speed > 0.5) {
                    // FAST: Sharp polygon petals with pointed tips
                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    
                    const length = size * (1.5 + speed * 0.8);
                    const width = size * 0.2;
                    const tipX = x + Math.cos(angle) * length;
                    const tipY = y + Math.sin(angle) * length;
                    
                    const perpAngle = angle + Math.PI / 2;
                    const baseLeft = {
                        x: x + Math.cos(perpAngle) * width,
                        y: y + Math.sin(perpAngle) * width
                    };
                    const baseRight = {
                        x: x - Math.cos(perpAngle) * width,
                        y: y - Math.sin(perpAngle) * width
                    };
                    
                    polygon.setAttribute('points', `${tipX},${tipY} ${baseLeft.x},${baseLeft.y} ${baseRight.x},${baseRight.y}`);
                    polygon.setAttribute('fill', color);
                    polygon.setAttribute('opacity', opacity);
                    
                    group.appendChild(polygon);
                } else {
                    // SLOW: Round ellipse petals
                    const petal = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
                    
                    const rx = size * 0.5; // Round, not thin
                    const ry = size * 0.8; // Not very long
                    const petalDistance = size * 0.4;
                    
                    petal.setAttribute('cx', x + Math.cos(angle) * petalDistance);
                    petal.setAttribute('cy', y + Math.sin(angle) * petalDistance);
                    petal.setAttribute('rx', rx);
                    petal.setAttribute('ry', ry);
                    petal.setAttribute('fill', color);
                    petal.setAttribute('opacity', opacity);
                    petal.setAttribute('transform', `rotate(${(i * 360 / petalCount) + 90} ${x + Math.cos(angle) * petalDistance} ${y + Math.sin(angle) * petalDistance})`);
                    
                    group.appendChild(petal);
                }
            }
            
            // Center
            const centerSize = speed > 0.5 ? size * 0.25 : size * 0.35;
            const center = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            center.setAttribute('cx', x);
            center.setAttribute('cy', y);
            center.setAttribute('r', centerSize);
            center.setAttribute('fill', speed > 0.5 ? '#ffb347' : '#ffd966');
            center.setAttribute('opacity', opacity);
            group.appendChild(center);
            
            // Add random animation delay for varied floating
            group.style.animationDelay = Math.random() * 2 + 's';
            group.style.animationDuration = (2.5 + Math.random() * 1.5) + 's';
            
            canvas.appendChild(group);
            flowers.push(group);
            flowerPositions.push({ x, y, size });
        }

        function handleKeyPress(e) {
            const key = e.key.toLowerCase();
            
            if (key.length !== 1 || !/[a-z]/.test(key)) return;
            
            calculateTypeSpeed();
            
            // Initialize main branches on first key
            if (mainBranches.length === 0) {
                initMainBranches();
            }
            
            if (vowels.includes(key)) {
                // Create flower
                let x, y;
                
                // Place flowers throughout the screen
                if (Math.random() > 0.3 && mainBranches.length > 0) {
                    const branchIndex = Math.floor(Math.random() * 4);
                    const point = getRandomPointOnMainBranch(branchIndex);
                    
                    const distance = typeSpeed < 0.5 ? 70 + Math.random() * 50 : 30 + Math.random() * 40;
                    const offsetAngle = Math.random() * Math.PI * 2;
                    
                    x = point.x + Math.cos(offsetAngle) * distance;
                    y = point.y + Math.sin(offsetAngle) * distance;
                } else {
                    // Random position on screen
                    x = 100 + Math.random() * (window.innerWidth - 200);
                    y = 150 + Math.random() * (window.innerHeight - 200);
                }
                
                createFlower(x, y, key, typeSpeed);
            } else if (consonants.includes(key)) {
                // Create branch
                let startX, startY, baseAngle;
                
                if (branches.length === 0 || Math.random() > 0.7) {
                    const branchIndex = Math.floor(Math.random() * 4);
                    const point = getRandomPointOnMainBranch(branchIndex);
                    startX = point.x;
                    startY = point.y;
                    baseAngle = point.angle;
                } else {
                    const lastBranch = branches[branches.length - 1];
                    startX = lastBranch.endX;
                    startY = lastBranch.endY;
                    baseAngle = lastBranch.angle;
                }
                
                createBranch(startX, startY, baseAngle, typeSpeed);
            }
        }

        function clearCanvas() {
            mainBranches.forEach(branch => {
                branch.element.classList.add('falling');
            });
            
            branches.forEach(branch => {
                branch.element.classList.add('falling');
            });
            
            flowers.forEach(flower => {
                flower.classList.add('falling');
            });
            
            setTimeout(() => {
                mainBranches.forEach(branch => branch.element.remove());
                branches.forEach(branch => branch.element.remove());
                flowers.forEach(flower => flower.remove());
                mainBranches = [];
                branches = [];
                flowers = [];
                flowerPositions = [];
            }, 2000);
        }

        document.addEventListener('keypress', handleKeyPress);
        clearBtn.addEventListener('click', clearCanvas);

        function resizeCanvas() {
            canvas.setAttribute('width', window.innerWidth);
            canvas.setAttribute('height', window.innerHeight);
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>
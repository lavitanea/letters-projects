<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualising Words</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: #fafaf8;
            overflow: hidden;
            height: 100vh;
        }

        #title {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            color: #8b7355;
            letter-spacing: 3px;
            z-index: 1000;
            text-transform: lowercase;
            font-weight: 300;
        }

        #clear-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            padding: 12px 28px;
            background: #d4a5a5;
            border: none;
            border-radius: 25px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s;
            letter-spacing: 1px;
            text-transform: lowercase;
        }

        #clear-btn:hover {
            background: #c49090;
            transform: scale(1.05);
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .flower {
            position: absolute;
            transform-origin: center;
            transition: opacity 0.8s;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% {
                transform: translate(0, 0) rotate(0deg);
            }
            25% {
                transform: translate(3px, -5px) rotate(2deg);
            }
            50% {
                transform: translate(-2px, -8px) rotate(-2deg);
            }
            75% {
                transform: translate(-4px, -3px) rotate(1deg);
            }
        }

        .falling {
            animation: fall 2s forwards !important;
        }

        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="title">visualising words</div>
    <svg id="canvas"></svg>
    <button id="clear-btn">clear</button>

    <script>
        const canvas = document.getElementById('canvas');
        const clearBtn = document.getElementById('clear-btn');
        
        const vowels = ['a', 'e', 'i', 'o', 'u', 'y'];
        const consonants = 'bcdfghjklmnpqrstvwxz'.split('');
        
        // Flower colors for each vowel
        const vowelColors = {
            'a': { main: '#ffb3ba', dark: '#ff8fa3' },
            'e': { main: '#ffc9de', dark: '#ffadd2' },
            'i': { main: '#bae1ff', dark: '#95d5ff' },
            'o': { main: '#e0b3ff', dark: '#d199ff' },
            'u': { main: '#c9b3ff', dark: '#b399ff' },
            'y': { main: '#d4c5f9', dark: '#c0aef5' }
        };

        let branches = [];
        let flowers = [];
        let lastTypeTime = Date.now();
        let typeSpeed = 0;
        let mainBranches = []; // Store the 4 main branches

        function calculateTypeSpeed() {
            const now = Date.now();
            const timeDiff = now - lastTypeTime;
            typeSpeed = Math.max(0, Math.min(1, 1 - (timeDiff / 800)));
            lastTypeTime = now;
        }

        function initMainBranches() {
            if (mainBranches.length > 0) return;
            
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            
            const corners = [
                { x: 80, y: 120, angle: Math.atan2(centerY - 120, centerX - 80) },
                { x: window.innerWidth - 80, y: 120, angle: Math.atan2(centerY - 120, centerX - (window.innerWidth - 80)) },
                { x: window.innerWidth - 80, y: window.innerHeight - 80, angle: Math.atan2(centerY - (window.innerHeight - 80), centerX - (window.innerWidth - 80)) },
                { x: 80, y: window.innerHeight - 80, angle: Math.atan2(centerY - (window.innerHeight - 80), centerX - 80) }
            ];
            
            corners.forEach((corner, index) => {
                const distance = Math.hypot(centerX - corner.x, centerY - corner.y);
                const length = distance * 0.6;
                const endX = corner.x + Math.cos(corner.angle) * length;
                const endY = corner.y + Math.sin(corner.angle) * length;
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const controlX = corner.x + Math.cos(corner.angle) * length * 0.5;
                const controlY = corner.y + Math.sin(corner.angle) * length * 0.5;
                
                path.setAttribute('d', `M ${corner.x} ${corner.y} Q ${controlX} ${controlY} ${endX} ${endY}`);
                path.setAttribute('stroke', '#8b7355');
                path.setAttribute('stroke-width', '5');
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke-linecap', 'round');
                
                canvas.appendChild(path);
                
                mainBranches.push({
                    element: path,
                    startX: corner.x,
                    startY: corner.y,
                    endX: endX,
                    endY: endY,
                    angle: corner.angle,
                    length: length
                });
            });
        }

        function getRandomPointOnMainBranch(branchIndex) {
            const branch = mainBranches[branchIndex];
            const t = 0.3 + Math.random() * 0.5; // Random point between 30% and 80% of branch
            
            const x = branch.startX + (branch.endX - branch.startX) * t;
            const y = branch.startY + (branch.endY - branch.startY) * t;
            
            return { x, y, angle: branch.angle };
        }

        function createBranch(startX, startY, baseAngle, speed) {
            const angleVariation = (Math.random() - 0.5) * Math.PI / 2;
            const angle = baseAngle + angleVariation;
            const length = 30 + Math.random() * 30 + speed * 40;
            
            const endX = startX + Math.cos(angle) * length;
            const endY = startY + Math.sin(angle) * length;
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            // Sharp or curved based on speed
            if (speed > 0.5) {
                // Sharp, direct line when fast
                path.setAttribute('d', `M ${startX} ${startY} L ${endX} ${endY}`);
            } else {
                // Curved when slow
                const controlX = startX + Math.cos(angle + 0.2) * length * 0.6;
                const controlY = startY + Math.sin(angle + 0.2) * length * 0.6;
                path.setAttribute('d', `M ${startX} ${startY} Q ${controlX} ${controlY} ${endX} ${endY}`);
            }
            
            // Color based on speed
            const speedColor = Math.floor(speed * 155);
            const r = 139 - speedColor;
            const g = 115 - speedColor;
            const b = 85 - speedColor;
            const color = `rgb(${r}, ${g}, ${b})`;
            
            path.setAttribute('stroke', color);
            path.setAttribute('stroke-width', Math.max(2, 2 + speed * 3));
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke-linecap', 'round');
            
            canvas.appendChild(path);
            branches.push({ element: path, endX, endY, angle });
            
            return { x: endX, y: endY };
        }

        function createFlower(x, y, vowel, speed) {
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('class', 'flower');
            group.style.left = x + 'px';
            group.style.top = y + 'px';
            
            const colors = vowelColors[vowel];
            const petalCount = 6;
            
            // Size and sharpness based on speed
            const baseSize = 12;
            const size = baseSize + speed * 25; // Grows much longer when fast
            const sharpness = speed * 0.8; // More extreme sharpness
            
            // Opacity based on speed
            const opacity = 0.3 + speed * 0.7; // 30% to 100%
            
            // Create petals
            for (let i = 0; i < petalCount; i++) {
                const angle = (i * 360 / petalCount) * Math.PI / 180;
                const petal = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
                
                // Sharp petals: very thin rx, long ry
                const rx = size * (0.15 + sharpness * 0.05); // Very thin
                const ry = size * (1.2 + sharpness * 0.8); // Very long
                
                const petalDistance = size * (0.4 + sharpness * 0.3);
                
                petal.setAttribute('cx', x + Math.cos(angle) * petalDistance);
                petal.setAttribute('cy', y + Math.sin(angle) * petalDistance);
                petal.setAttribute('rx', rx);
                petal.setAttribute('ry', ry);
                petal.setAttribute('fill', speed > 0.5 ? colors.dark : colors.main);
                petal.setAttribute('opacity', opacity);
                petal.setAttribute('transform', `rotate(${(i * 360 / petalCount) + 90} ${x + Math.cos(angle) * petalDistance} ${y + Math.sin(angle) * petalDistance})`);
                
                group.appendChild(petal);
            }
            
            // Center
            const centerSize = Math.max(3, size * 0.2);
            const center = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            center.setAttribute('cx', x);
            center.setAttribute('cy', y);
            center.setAttribute('r', centerSize);
            center.setAttribute('fill', '#ffd966');
            center.setAttribute('opacity', opacity);
            group.appendChild(center);
            
            // Add random animation delay for varied floating
            group.style.animationDelay = Math.random() * 2 + 's';
            group.style.animationDuration = (2.5 + Math.random() * 1.5) + 's';
            
            canvas.appendChild(group);
            flowers.push(group);
        }

        function handleKeyPress(e) {
            const key = e.key.toLowerCase();
            
            if (key.length !== 1 || !/[a-z]/.test(key)) return;
            
            calculateTypeSpeed();
            
            // Initialize main branches on first key
            if (mainBranches.length === 0) {
                initMainBranches();
            }
            
            if (vowels.includes(key)) {
                // Create flower away from branches when slow, can overlap when fast
                let x, y;
                const branchIndex = Math.floor(Math.random() * 4);
                const point = getRandomPointOnMainBranch(branchIndex);
                
                // Distance from branch based on speed
                const distance = typeSpeed < 0.5 ? 60 + Math.random() * 40 : 20 + Math.random() * 30;
                const offsetAngle = point.angle + Math.PI / 2 + (Math.random() - 0.5) * Math.PI;
                
                x = point.x + Math.cos(offsetAngle) * distance;
                y = point.y + Math.sin(offsetAngle) * distance;
                
                createFlower(x, y, key, typeSpeed);
            } else if (consonants.includes(key)) {
                // Create branch growing from main branches or previous branches
                let startX, startY, baseAngle;
                
                if (branches.length === 0 || Math.random() > 0.7) {
                    // Start from main branch
                    const branchIndex = Math.floor(Math.random() * 4);
                    const point = getRandomPointOnMainBranch(branchIndex);
                    startX = point.x;
                    startY = point.y;
                    baseAngle = point.angle;
                } else {
                    // Grow from existing branch
                    const lastBranch = branches[branches.length - 1];
                    startX = lastBranch.endX;
                    startY = lastBranch.endY;
                    baseAngle = lastBranch.angle;
                }
                
                createBranch(startX, startY, baseAngle, typeSpeed);
            }
        }

        function clearCanvas() {
            // Add falling animation to branches
            mainBranches.forEach(branch => {
                branch.element.classList.add('falling');
            });
            
            branches.forEach(branch => {
                branch.element.classList.add('falling');
            });
            
            flowers.forEach(flower => {
                flower.classList.add('falling');
            });
            
            // Clear arrays and remove elements after animation
            setTimeout(() => {
                mainBranches.forEach(branch => branch.element.remove());
                branches.forEach(branch => branch.element.remove());
                flowers.forEach(flower => flower.remove());
                mainBranches = [];
                branches = [];
                flowers = [];
            }, 2000);
        }

        document.addEventListener('keypress', handleKeyPress);
        clearBtn.addEventListener('click', clearCanvas);

        // Set canvas size
        function resizeCanvas() {
            canvas.setAttribute('width', window.innerWidth);
            canvas.setAttribute('height', window.innerHeight);
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>
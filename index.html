<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualising Words</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: #fafaf8;
            overflow: hidden;
            height: 100vh;
        }

        #title {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            color: #8b7355;
            letter-spacing: 3px;
            z-index: 1000;
            text-transform: lowercase;
            font-weight: 300;
        }

        #clear-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            padding: 12px 28px;
            background: #d4a5a5;
            border: none;
            border-radius: 25px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s;
            letter-spacing: 1px;
            text-transform: lowercase;
        }

        #clear-btn:hover {
            background: #c49090;
            transform: scale(1.05);
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .branch {
            position: absolute;
            transform-origin: bottom center;
            transition: opacity 0.8s;
        }

        .flower {
            position: absolute;
            width: 40px;
            height: 40px;
            transform-origin: center;
            transition: opacity 0.8s;
        }

        .falling {
            animation: fall 2s forwards;
        }

        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="title">visualising words</div>
    <svg id="canvas"></svg>
    <button id="clear-btn">clear</button>

    <script>
        const canvas = document.getElementById('canvas');
        const clearBtn = document.getElementById('clear-btn');
        
        const vowels = ['a', 'e', 'i', 'o', 'u', 'y'];
        const consonants = 'bcdfghjklmnpqrstvwxz'.split('');
        
        // Flower colors for each vowel
        const vowelColors = {
            'a': { main: '#ffb3ba', dark: '#ff8fa3' },
            'e': { main: '#ffc9de', dark: '#ffadd2' },
            'i': { main: '#bae1ff', dark: '#95d5ff' },
            'o': { main: '#e0b3ff', dark: '#d199ff' },
            'u': { main: '#c9b3ff', dark: '#b399ff' },
            'y': { main: '#d4c5f9', dark: '#c0aef5' }
        };

        // Assign each consonant a unique color
        const consonantColors = {};
        const pastelleColors = [
            '#ffb3ba', '#ffdfba', '#ffffba', '#baffc9', '#bae1ff',
            '#e0b3ff', '#ffc9de', '#ffd4ba', '#baf3ba', '#d4baff',
            '#ffbacc', '#baffba', '#babfff', '#ffbae6', '#baffe6',
            '#f0baff', '#ffccba', '#e6ffba', '#bae6ff', '#ffbad4'
        ];
        
        consonants.forEach((c, i) => {
            consonantColors[c] = pastelleColors[i % pastelleColors.length];
        });

        let branches = [];
        let flowers = [];
        let lastTypeTime = Date.now();
        let typeSpeed = 0;
        let currentCorner = 0; // 0: top-left, 1: top-right, 2: bottom-right, 3: bottom-left
        let cornerPositions = [];
        let branchCount = 0;

        function getCornerPosition() {
            const corners = [
                { x: 50, y: 100 },
                { x: window.innerWidth - 50, y: 100 },
                { x: window.innerWidth - 50, y: window.innerHeight - 50 },
                { x: 50, y: window.innerHeight - 50 }
            ];
            
            const position = corners[currentCorner];
            currentCorner = (currentCorner + 1) % 4;
            return position;
        }

        function getProgressPosition(startX, startY, progress) {
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            
            return {
                x: startX + (centerX - startX) * progress,
                y: startY + (centerY - startY) * progress
            };
        }

        function calculateTypeSpeed() {
            const now = Date.now();
            const timeDiff = now - lastTypeTime;
            typeSpeed = Math.max(0, Math.min(1, 1 - (timeDiff / 1000)));
            lastTypeTime = now;
        }

        function createBranch(x, y, angle, length, color) {
            const endX = x + Math.cos(angle) * length;
            const endY = y + Math.sin(angle) * length;
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const controlX = x + Math.cos(angle + 0.3) * length * 0.7;
            const controlY = y + Math.sin(angle + 0.3) * length * 0.7;
            
            path.setAttribute('d', `M ${x} ${y} Q ${controlX} ${controlY} ${endX} ${endY}`);
            path.setAttribute('stroke', color);
            path.setAttribute('stroke-width', Math.max(1, 4 - typeSpeed * 2));
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke-linecap', 'round');
            
            canvas.appendChild(path);
            branches.push({ element: path, endX, endY, angle });
            
            return { x: endX, y: endY };
        }

        function createFlower(x, y, vowel, speed) {
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('class', 'flower');
            
            const colors = vowelColors[vowel];
            const petalCount = 5 + Math.floor(Math.random() * 3);
            const size = 15 + speed * 15;
            const sharpness = speed * 0.5;
            
            for (let i = 0; i < petalCount; i++) {
                const angle = (i * 360 / petalCount) * Math.PI / 180;
                const petal = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
                
                const rx = size * (0.4 + sharpness * 0.3);
                const ry = size * (1 - sharpness * 0.4);
                
                petal.setAttribute('cx', x + Math.cos(angle) * size * 0.3);
                petal.setAttribute('cy', y + Math.sin(angle) * size * 0.3);
                petal.setAttribute('rx', rx);
                petal.setAttribute('ry', ry);
                petal.setAttribute('fill', speed > 0.5 ? colors.dark : colors.main);
                petal.setAttribute('opacity', 0.7 + speed * 0.3);
                petal.setAttribute('transform', `rotate(${i * 360 / petalCount} ${x} ${y})`);
                
                group.appendChild(petal);
            }
            
            // Center
            const center = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            center.setAttribute('cx', x);
            center.setAttribute('cy', y);
            center.setAttribute('r', size * 0.25);
            center.setAttribute('fill', '#ffd966');
            group.appendChild(center);
            
            canvas.appendChild(group);
            flowers.push(group);
        }

        function handleKeyPress(e) {
            const key = e.key.toLowerCase();
            
            if (key.length !== 1 || !/[a-z]/.test(key)) return;
            
            calculateTypeSpeed();
            
            const progress = (branchCount * 0.05) % 1;
            
            if (vowels.includes(key)) {
                // Create flower on last branch or random position
                let x, y;
                if (branches.length > 0) {
                    const lastBranch = branches[branches.length - 1];
                    x = lastBranch.endX + (Math.random() - 0.5) * 30;
                    y = lastBranch.endY + (Math.random() - 0.5) * 30;
                } else {
                    const corner = getCornerPosition();
                    const pos = getProgressPosition(corner.x, corner.y, progress);
                    x = pos.x;
                    y = pos.y;
                }
                
                createFlower(x, y, key, typeSpeed);
            } else if (consonants.includes(key)) {
                // Create branch
                let startX, startY;
                
                if (branches.length === 0 || branchCount % 8 === 0) {
                    const corner = getCornerPosition();
                    cornerPositions.push(corner);
                    startX = corner.x;
                    startY = corner.y;
                } else {
                    const lastBranch = branches[branches.length - 1];
                    startX = lastBranch.endX;
                    startY = lastBranch.endY;
                }
                
                const baseAngle = Math.atan2(
                    window.innerHeight / 2 - startY,
                    window.innerWidth / 2 - startX
                );
                
                const angle = baseAngle + (Math.random() - 0.5) * Math.PI / 3;
                const length = 40 + Math.random() * 40 + typeSpeed * 30;
                
                // Color based on speed
                const speedColor = Math.floor(typeSpeed * 155);
                const r = 139 - speedColor;
                const g = 115 - speedColor;
                const b = 85 - speedColor;
                const color = `rgb(${r}, ${g}, ${b})`;
                
                createBranch(startX, startY, angle, length, color);
                branchCount++;
            }
        }

        function clearCanvas() {
            // Add falling animation
            branches.forEach(branch => {
                branch.element.classList.add('falling');
            });
            
            flowers.forEach(flower => {
                flower.classList.add('falling');
            });
            
            // Clear arrays and remove elements after animation
            setTimeout(() => {
                branches.forEach(branch => branch.element.remove());
                flowers.forEach(flower => flower.remove());
                branches = [];
                flowers = [];
                branchCount = 0;
                currentCorner = 0;
                cornerPositions = [];
            }, 2000);
        }

        document.addEventListener('keypress', handleKeyPress);
        clearBtn.addEventListener('click', clearCanvas);

        // Set canvas size
        function resizeCanvas() {
            canvas.setAttribute('width', window.innerWidth);
            canvas.setAttribute('height', window.innerHeight);
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>
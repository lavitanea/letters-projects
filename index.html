<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Garden of Letters</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  
  body {
    margin: 0;
    font-family: 'Georgia', serif;
    overflow: hidden;
    background: linear-gradient(180deg, #a8d8ea 0%, #c8e5f0 40%, #9ec89e 70%, #7ea85c 100%);
    position: relative;
  }
  
  /* Detailed grass field */
  .grass-layer {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 40%;
    background: 
      repeating-linear-gradient(
        92deg,
        transparent,
        transparent 1px,
        rgba(107, 142, 35, 0.08) 1px,
        rgba(107, 142, 35, 0.08) 2px
      ),
      repeating-linear-gradient(
        88deg,
        transparent,
        transparent 2px,
        rgba(85, 107, 47, 0.06) 2px,
        rgba(85, 107, 47, 0.06) 3px
      ),
      linear-gradient(180deg, transparent 0%, rgba(85, 107, 47, 0.3) 50%, rgba(75, 97, 37, 0.5) 100%);
    pointer-events: none;
  }
  
  /* Individual grass blades */
  .grass-blade {
    position: fixed;
    bottom: 0;
    width: 2px;
    background: linear-gradient(to top, #5a7d3a, #8eb65e, transparent);
    transform-origin: bottom center;
    opacity: 0.5;
    animation: sway 3s ease-in-out infinite;
  }
  
  .grass-blade.tall {
    width: 3px;
    opacity: 0.7;
    background: linear-gradient(to top, #4a6d2a, #7ea64e, transparent);
  }
  
  @keyframes sway {
    0%, 100% { transform: rotate(-3deg); }
    50% { transform: rotate(3deg); }
  }
  
  /* Rain effect */
  .raindrop {
    position: fixed;
    width: 2px;
    height: 20px;
    background: linear-gradient(transparent, rgba(174, 194, 224, 0.6));
    animation: fall linear;
    pointer-events: none;
  }
  
  @keyframes fall {
    to { transform: translateY(100vh); }
  }
  
  #app {
    position: relative;
    height: 100vh;
    overflow: hidden;
  }
  
  h1 {
    position: absolute;
    left: 32px;
    top: 24px;
    margin: 0;
    color: #2c3e1f;
    font-weight: 400;
    font-size: 28px;
    letter-spacing: 1px;
    text-shadow: 0 2px 4px rgba(255, 255, 255, 0.5);
  }
  
  #typedDisplay {
    position: absolute;
    left: 32px;
    bottom: 24px;
    background: rgba(255, 255, 255, 0.85);
    color: #2c3e1f;
    padding: 12px 24px;
    border-radius: 20px;
    border: 2px solid rgba(255, 255, 255, 0.9);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    font-size: 18px;
    font-family: 'Courier New', monospace;
    max-width: 70%;
    max-height: 150px;
    overflow-y: auto;
    overflow-x: hidden;
    word-wrap: break-word;
    letter-spacing: 2px;
    min-width: 200px;
  }
  
  #typedDisplay::-webkit-scrollbar {
    width: 6px;
  }
  
  #typedDisplay::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.3);
    border-radius: 10px;
  }
  
  #typedDisplay::-webkit-scrollbar-thumb {
    background: rgba(44, 62, 31, 0.4);
    border-radius: 10px;
  }
  
  #controls {
    position: absolute;
    right: 24px;
    top: 24px;
    display: flex;
    gap: 12px;
  }
  
  button {
    background: rgba(255, 255, 255, 0.9);
    border: 2px solid rgba(255, 255, 255, 0.95);
    padding: 10px 20px;
    border-radius: 20px;
    font-weight: 600;
    font-size: 14px;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    color: #2c3e1f;
    transition: transform 0.2s, box-shadow 0.2s;
  }
  
  button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
  }
  
  button:active {
    transform: translateY(0);
  }
  
  /* Sun */
  .sun {
    position: fixed;
    top: 80px;
    right: 100px;
    width: 80px;
    height: 80px;
    background: radial-gradient(circle, #ffe66d 0%, #ffed4e 50%, transparent 70%);
    border-radius: 50%;
    opacity: 1;
    transition: opacity 1s;
    pointer-events: none;
    box-shadow: 0 0 60px rgba(255, 230, 109, 0.6);
  }
  
  .sun.hidden {
    opacity: 0;
  }
  
  canvas {
    display: block;
  }
</style>
</head>
<body>
<!-- Grass layers -->
<div class="grass-layer"></div>
<script>
  // Generate detailed grass blades
  for (let i = 0; i < 150; i++) {
    const blade = document.createElement('div');
    blade.className = Math.random() > 0.7 ? 'grass-blade tall' : 'grass-blade';
    blade.style.left = Math.random() * 100 + '%';
    blade.style.height = (15 + Math.random() * 50) + 'px';
    blade.style.animationDelay = Math.random() * 3 + 's';
    blade.style.animationDuration = (2 + Math.random() * 3) + 's';
    document.body.appendChild(blade);
  }
</script>

<!-- Sun -->
<div class="sun" id="sun"></div>

<div id="app">
  <h1>The Garden of Letters</h1>
  <div id="typedDisplay">Type to grow your garden...</div>
  <div id="controls">
    <button id="clearBtn">Clear Garden</button>
    <button id="exportBtn">Save Image</button>
  </div>
  <canvas id="visualCanvas"></canvas>
</div>
<script>
(() => {
  const canvas = document.getElementById('visualCanvas');
  const ctx = canvas.getContext('2d', { alpha: true });
  let W = canvas.width = window.innerWidth;
  let H = canvas.height = window.innerHeight;
  window.addEventListener('resize', () => { 
    W = canvas.width = window.innerWidth; 
    H = canvas.height = window.innerHeight; 
  });

  // Rain sound setup using Web Audio API
  let audioContext = null;
  let rainGainNode = null;
  let rainOscillators = [];
  
  function createRainSound() {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    
    // Stop any existing rain sounds
    stopRainSound();
    
    // Create gain node for volume control
    rainGainNode = audioContext.createGain();
    rainGainNode.gain.value = 0.15;
    rainGainNode.connect(audioContext.destination);
    
    // Create multiple oscillators for rain-like white noise
    for (let i = 0; i < 3; i++) {
      const oscillator = audioContext.createOscillator();
      const filter = audioContext.createBiquadFilter();
      const gain = audioContext.createGain();
      
      // White noise simulation with filtered oscillators
      oscillator.type = 'sawtooth';
      oscillator.frequency.value = Math.random() * 200 + 100;
      
      filter.type = 'lowpass';
      filter.frequency.value = 800 + Math.random() * 400;
      filter.Q.value = 0.5;
      
      gain.gain.value = 0.3;
      
      oscillator.connect(filter);
      filter.connect(gain);
      gain.connect(rainGainNode);
      
      oscillator.start();
      rainOscillators.push({ oscillator, filter, gain });
      
      // Vary the frequency slightly over time for realistic effect
      setInterval(() => {
        if (rainOscillators.length > 0) {
          filter.frequency.value = 800 + Math.random() * 400;
        }
      }, 200);
    }
  }
  
  function stopRainSound() {
    if (rainOscillators.length > 0) {
      rainOscillators.forEach(({ oscillator }) => {
        try {
          oscillator.stop();
        } catch (e) {
          // Already stopped
        }
      });
      rainOscillators = [];
    }
    if (rainGainNode) {
      rainGainNode.disconnect();
      rainGainNode = null;
    }
  }

  // STATE
  const trees = []; // Multiple trees
  const flowers = [];
  let typed = '';
  const keyTimes = [];
  const MIN_HISTORY = 15;
  let currentStage = 1;
  let isRaining = false;
  const raindrops = [];

  // Pastel colors for each vowel
  const vowelColors = {
    a: '#ffb3ba',
    e: '#ffffba',
    i: '#bae1ff',
    o: '#ffdfba',
    u: '#e0bbff'
  };

  function random(min, max) { 
    return Math.random() * (max - min) + min; 
  }

  function dist(ax, ay, bx, by) { 
    return Math.hypot(bx - ax, by - ay); 
  }

  // Create a new tree
  function createTree(xPos) {
    const trunk = {
      x1: xPos,
      y1: H - 80,
      x2: xPos,
      y2: H - 200,
      angle: -Math.PI / 2,
      thickness: 12,
      segments: [],
      branches: []
    };
    
    trunk.segments = createTrunkSegments(trunk);
    return trunk;
  }

  function createTrunkSegments(branch) {
    const segments = [];
    const numSegments = 8;
    for (let i = 0; i <= numSegments; i++) {
      const t = i / numSegments;
      const x = branch.x1 + (branch.x2 - branch.x1) * t;
      const y = branch.y1 + (branch.y2 - branch.y1) * t;
      const thickness = branch.thickness * (1 - t * 0.3);
      segments.push({ x, y, thickness });
    }
    return segments;
  }

  // Start with first tree in center
  trees.push(createTree(W / 2));

  function getBranchColor(stage) {
    const colors = [
      [139, 111, 71],
      [100, 80, 50],
      [70, 55, 35],
      [45, 35, 25]
    ];
    const c = colors[stage - 1];
    return `rgb(${c[0]}, ${c[1]}, ${c[2]})`;
  }

  function addBranch(tree, parent, stage) {
    const base = parent.angle || -Math.PI / 2;
    let angle = base + random(-Math.PI / 4, Math.PI / 4);
    const len = random(70, 120);
    const x1 = parent.segments[parent.segments.length - 1].x;
    const y1 = parent.segments[parent.segments.length - 1].y;
    
    const curvature = random(-0.3, 0.3);
    const midX = x1 + Math.cos(angle) * len * 0.5 + Math.cos(angle + Math.PI/2) * curvature * 30;
    const midY = y1 + Math.sin(angle) * len * 0.5 + Math.sin(angle + Math.PI/2) * curvature * 30;
    const x2 = x1 + Math.cos(angle) * len;
    const y2 = y1 + Math.sin(angle) * len;

    const thickness = 4 + stage * 1.5;
    
    const branch = {
      x1, y1, x2, y2, midX, midY, angle,
      thickness,
      parent,
      children: [],
      segments: [],
      tree: tree
    };
    
    const numSegments = 6;
    for (let i = 0; i <= numSegments; i++) {
      const t = i / numSegments;
      const x = (1-t)*(1-t)*x1 + 2*(1-t)*t*midX + t*t*x2;
      const y = (1-t)*(1-t)*y1 + 2*(1-t)*t*midY + t*t*y2;
      const segThickness = thickness * (1 - t * 0.4);
      branch.segments.push({ x, y, thickness: segThickness });
    }
    
    tree.branches.push(branch);
    if (parent.children) parent.children.push(branch);
    return branch;
  }

  function addFlower(branch, letter, stage) {
    const count = flowers.filter(f => f.char === letter).length;
    const segmentIdx = Math.floor(branch.segments.length * (0.4 + (count % 4) * 0.15));
    const segment = branch.segments[Math.min(segmentIdx, branch.segments.length - 1)];
    
    // Calculate distance from tree center for spreading effect
    const treeX = branch.tree ? branch.tree.x1 : W / 2;
    const distanceFromCenter = Math.abs(segment.x - treeX);
    const spreadFactor = Math.min(1, flowers.length / 20); // Gradually spread outward
    
    const offsetDist = 35 + distanceFromCenter * 0.3 + spreadFactor * 40;
    const offsetAngle = random(0, Math.PI * 2);
    const x = segment.x + Math.cos(offsetAngle) * offsetDist;
    const y = segment.y + Math.sin(offsetAngle) * offsetDist;

    const baseColor = vowelColors[letter.toLowerCase()] || '#ffccdd';
    
    let size, petalCount, layerCount, sharpness, color;
    
    switch(stage) {
      case 1:
        size = 16;
        petalCount = 5;
        layerCount = 3;
        sharpness = 0;
        color = baseColor;
        break;
      case 2:
        size = 20;
        petalCount = 6;
        layerCount = 4;
        sharpness = 0.2;
        color = brightenColor(baseColor, 10);
        break;
      case 3:
        size = 26;
        petalCount = 7;
        layerCount = 3;
        sharpness = 0.6;
        color = brightenColor(baseColor, 25);
        break;
      case 4:
        size = 32;
        petalCount = 8;
        layerCount = 2;
        sharpness = 1;
        const neonColors = {
          a: '#ff1a75',
          e: '#ffff00',
          i: '#00d4ff',
          o: '#ff6600',
          u: '#b000ff'
        };
        color = neonColors[letter.toLowerCase()] || '#ff0099';
        break;
    }

    const flower = {
      x, y,
      color,
      char: letter,
      stage,
      size,
      petalCount,
      layerCount,
      sharpness,
      createdAt: performance.now(),
      floatPhase: random(0, Math.PI * 2),
      rotationOffset: random(0, Math.PI * 2)
    };
    
    flowers.push(flower);
  }

  function brightenColor(hex, percent) {
    const num = parseInt(hex.replace('#', ''), 16);
    const amt = Math.round(2.55 * percent);
    const R = Math.min(255, (num >> 16) + amt);
    const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
    const B = Math.min(255, (num & 0x0000FF) + amt);
    return `rgb(${R}, ${G}, ${B})`;
  }

  function drawFlower(f, t) {
    ctx.save();
    
    const age = (t - f.createdAt) / 1000;
    const fx = f.x + Math.cos(t / 1200 + f.floatPhase) * 2;
    const fy = f.y + Math.sin(t / 1000 + f.floatPhase) * 3;
    
    ctx.translate(fx, fy);
    ctx.rotate(t / 8000 + f.rotationOffset);
    
    const scale = Math.min(1, age * 3);
    ctx.scale(scale, scale);
    
    // Reduced glow for stage 4
    if (f.stage === 4) {
      ctx.shadowBlur = 15;
      ctx.shadowColor = f.color;
    } else {
      ctx.shadowBlur = 6;
      ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
    }
    
    // Draw petal layers
    for (let layer = f.layerCount - 1; layer >= 0; layer--) {
      const layerSize = 1 - (layer * 0.15);
      const layerRotation = (layer * Math.PI / f.petalCount) * 0.5;
      
      ctx.save();
      ctx.rotate(layerRotation);
      ctx.globalAlpha = 0.9 - layer * 0.1;
      
      const angleStep = (Math.PI * 2) / f.petalCount;
      for (let i = 0; i < f.petalCount; i++) {
        const angle = angleStep * i;
        ctx.save();
        ctx.rotate(angle);
        
        ctx.beginPath();
        
        if (f.sharpness > 0.5) {
          const tipDist = f.size * layerSize * 2.2;
          const baseWidth = f.size * layerSize * (0.5 - f.sharpness * 0.2);
          const controlDist = f.size * layerSize * 1.2;
          
          ctx.moveTo(0, -f.size * layerSize * 0.3);
          ctx.quadraticCurveTo(-baseWidth, -controlDist, 0, -tipDist);
          ctx.quadraticCurveTo(baseWidth, -controlDist, 0, -f.size * layerSize * 0.3);
          ctx.closePath();
        } else {
          const petalLength = f.size * layerSize * 1.6;
          const petalWidth = f.size * layerSize * 1.1;
          const centerY = -f.size * layerSize * 0.9;
          
          ctx.moveTo(0, -f.size * layerSize * 0.2);
          ctx.bezierCurveTo(
            -petalWidth * 0.5, centerY - petalLength * 0.3,
            -petalWidth * 0.3, centerY - petalLength * 0.8,
            0, centerY - petalLength
          );
          ctx.bezierCurveTo(
            petalWidth * 0.3, centerY - petalLength * 0.8,
            petalWidth * 0.5, centerY - petalLength * 0.3,
            0, -f.size * layerSize * 0.2
          );
          ctx.closePath();
        }
        
        const gradient = ctx.createRadialGradient(0, -f.size * layerSize * 0.5, 0, 0, -f.size * layerSize, f.size * layerSize);
        const darkAmount = layer * 8 + 5;
        gradient.addColorStop(0, brightenColor(f.color, 15));
        gradient.addColorStop(1, brightenColor(f.color, -darkAmount));
        
        ctx.fillStyle = gradient;
        ctx.fill();
        
        ctx.restore();
      }
      
      ctx.restore();
    }
    
    // Center - NO black circle for stage 4
    const centerSize = f.size * 0.5;
    ctx.beginPath();
    ctx.arc(0, 0, centerSize, 0, Math.PI * 2);
    
    const centerGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, centerSize);
    if (f.stage === 4) {
      // Bright center for neon flowers
      centerGradient.addColorStop(0, '#ffffff');
      centerGradient.addColorStop(1, brightenColor(f.color, 30));
    } else {
      centerGradient.addColorStop(0, '#fffacd');
      centerGradient.addColorStop(1, '#d4a017');
    }
    ctx.fillStyle = centerGradient;
    ctx.fill();
    
    // Stamens for realistic touch (stages 1-2)
    if (f.stage <= 2) {
      ctx.globalAlpha = 0.7;
      for (let i = 0; i < 8; i++) {
        const angle = (Math.PI * 2 * i) / 8;
        const sx = Math.cos(angle) * centerSize * 0.6;
        const sy = Math.sin(angle) * centerSize * 0.6;
        ctx.beginPath();
        ctx.arc(sx, sy, 1.5, 0, Math.PI * 2);
        ctx.fillStyle = '#8B4513';
        ctx.fill();
      }
    }
    
    ctx.restore();
  }

  function drawBranch(b) {
    if (!b.segments || b.segments.length < 2) return;
    
    const color = getBranchColor(currentStage);
    
    for (let i = 0; i < b.segments.length - 1; i++) {
      const s1 = b.segments[i];
      const s2 = b.segments[i + 1];
      
      ctx.strokeStyle = color;
      ctx.lineWidth = s1.thickness;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      
      ctx.beginPath();
      ctx.moveTo(s1.x, s1.y);
      ctx.lineTo(s2.x, s2.y);
      ctx.stroke();
      
      if (i % 2 === 0 && s1.thickness > 6) {
        ctx.strokeStyle = brightenColor(color, -15);
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(s1.x - 2, s1.y);
        ctx.lineTo(s1.x + 2, s1.y + 3);
        ctx.stroke();
      }
    }
  }

  function computeStage() {
    if (keyTimes.length < MIN_HISTORY) return 1;
    
    const recent = keyTimes.slice(-MIN_HISTORY);
    const diffs = [];
    for (let i = 1; i < recent.length; i++) {
      diffs.push(recent[i] - recent[i - 1]);
    }
    
    const avgDelay = diffs.reduce((a, b) => a + b, 0) / diffs.length;
    const keysPerSecond = 1000 / avgDelay;
    
    // Check for rain (very fast typing)
    if (keysPerSecond > 7) {
      startRain();
    } else if (keysPerSecond < 4) {
      stopRain();
    }
    
    if (keysPerSecond < 2) return 1;
    if (keysPerSecond < 3.5) return 2;
    if (keysPerSecond < 5.5) return 3;
    return 4;
  }

  function startRain() {
    if (isRaining) return;
    isRaining = true;
    document.getElementById('sun').classList.add('hidden');
    
    // Start rain sound
    createRainSound();
    
    // Create rain effect
    const rainInterval = setInterval(() => {
      if (!isRaining) {
        clearInterval(rainInterval);
        return;
      }
      
      for (let i = 0; i < 3; i++) {
        const drop = document.createElement('div');
        drop.className = 'raindrop';
        drop.style.left = Math.random() * 100 + '%';
        drop.style.top = -20 + 'px';
        drop.style.animationDuration = (0.5 + Math.random() * 0.3) + 's';
        document.body.appendChild(drop);
        
        setTimeout(() => drop.remove(), 1000);
      }
    }, 50);
  }

  function stopRain() {
    if (!isRaining) return;
    isRaining = false;
    document.getElementById('sun').classList.remove('hidden');
    
    // Stop rain sound
    stopRainSound();
  }

  // RENDER LOOP
  function render(t) {
    ctx.clearRect(0, 0, W, H);
    
    // Draw all trees
    trees.forEach(tree => {
      drawBranch(tree);
      tree.branches.forEach(b => drawBranch(b));
    });
    
    // Draw flowers
    flowers.forEach(f => drawFlower(f, t));
    
    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);

  // TYPING HANDLER
  document.addEventListener('keydown', (e) => {
    // Handle spacebar for new tree
    if (e.key === ' ') {
      e.preventDefault();
      const spacing = W / (trees.length + 1);
      const newX = spacing * (trees.length + 1);
      const newTree = createTree(newX);
      trees.push(newTree);
      typed += ' ';
      const display = document.getElementById('typedDisplay');
      display.innerText = typed;
      display.scrollTop = display.scrollHeight;
      return;
    }
    
    if (e.key.length === 1 && /[a-z]/i.test(e.key)) {
      const now = performance.now();
      keyTimes.push(now);
      
      if (keyTimes.length >= MIN_HISTORY) {
        currentStage = computeStage();
      }

      const letter = e.key;
      typed += letter;
      const display = document.getElementById('typedDisplay');
      display.innerText = typed;
      display.scrollTop = display.scrollHeight;

      const isVowel = /[aeiou]/i.test(letter);

      if (!isVowel) {
        // CONSONANTS create flowers - only on branches!
        const currentTree = trees[trees.length - 1];
        
        // Only use branches if they exist, otherwise use trunk
        if (currentTree.branches.length > 0) {
          const targetBranch = currentTree.branches[flowers.length % currentTree.branches.length];
          addFlower(targetBranch, letter, currentStage);
        } else {
          // If no branches yet, wait or use trunk as temporary
          addFlower(currentTree, letter, currentStage);
        }
      } else {
        // VOWELS grow branches
        const currentTree = trees[trees.length - 1];
        const upperBranches = currentTree.branches.filter(b => b.segments && b.segments[b.segments.length - 1].y < H - 100);
        const parent = upperBranches.length > 0 
          ? upperBranches[Math.floor(Math.random() * upperBranches.length)]
          : currentTree;
        
        addBranch(currentTree, parent, currentStage);
      }
    }
  });

  // CLEAR with falling animation
  document.getElementById('clearBtn').addEventListener('click', () => {
    const fallInterval = setInterval(() => {
      trees.forEach(tree => {
        if (tree.segments) tree.segments.forEach(s => s.y += 15);
        tree.branches.forEach(b => {
          if (b.segments) b.segments.forEach(s => s.y += 15);
        });
      });
      flowers.forEach(f => f.y += 15);
      
      if (trees[0] && trees[0].segments[0].y > H + 150) {
        clearInterval(fallInterval);
        trees.length = 0;
        flowers.length = 0;
        typed = '';
        keyTimes.length = 0;
        currentStage = 1;
        stopRain();
        document.getElementById('typedDisplay').innerText = 'Type to grow your garden...';
        
        trees.push(createTree(W / 2));
      }
    }, 30);
  });

  // EXPORT
  document.getElementById('exportBtn').addEventListener('click', () => {
    const url = canvas.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    a.download = 'garden-of-letters.png';
    a.click();
  });

  // Seed initial branches
  setTimeout(() => {
    for (let i = 0; i < 3; i++) {
      setTimeout(() => {
        const tree = trees[0];
        const parent = tree.branches.length > 0 
          ? tree.branches[Math.floor(Math.random() * tree.branches.length)]
          : tree;
        addBranch(tree, parent, 1);
      }, i * 200);
    }
  }, 300);

})();
</script>
</body>
</html>
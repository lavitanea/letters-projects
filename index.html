<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Garden of Letters</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  
  body {
    margin: 0;
    font-family: 'Georgia', serif;
    overflow: hidden;
    background: linear-gradient(180deg, #a8d8ea 0%, #c8e5f0 40%, #9ec89e 70%, #7ea85c 100%);
    position: relative;
  }
  
  /* Detailed grass field */
  .grass-layer {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 40%;
    background: 
      repeating-linear-gradient(
        92deg,
        transparent,
        transparent 1px,
        rgba(107, 142, 35, 0.08) 1px,
        rgba(107, 142, 35, 0.08) 2px
      ),
      repeating-linear-gradient(
        88deg,
        transparent,
        transparent 2px,
        rgba(85, 107, 47, 0.06) 2px,
        rgba(85, 107, 47, 0.06) 3px
      ),
      linear-gradient(180deg, transparent 0%, rgba(85, 107, 47, 0.3) 50%, rgba(75, 97, 37, 0.5) 100%);
    pointer-events: none;
  }
  
  /* Individual grass blades */
  .grass-blade {
    position: fixed;
    bottom: 0;
    width: 2px;
    background: linear-gradient(to top, #5a7d3a, #8eb65e, transparent);
    transform-origin: bottom center;
    opacity: 0.5;
    animation: sway 3s ease-in-out infinite;
  }
  
  .grass-blade.tall {
    width: 3px;
    opacity: 0.7;
    background: linear-gradient(to top, #4a6d2a, #7ea64e, transparent);
  }
  
  @keyframes sway {
    0%, 100% { transform: rotate(-3deg); }
    50% { transform: rotate(3deg); }
  }
  
  /* Rain effect */
  .raindrop {
    position: fixed;
    width: 2px;
    height: 20px;
    background: linear-gradient(transparent, rgba(174, 194, 224, 0.6));
    animation: fall linear;
    pointer-events: none;
  }
  
  @keyframes fall {
    to { transform: translateY(100vh); }
  }
  
  #app {
    position: relative;
    height: 100vh;
    overflow: hidden;
  }
  
  h1 {
    position: absolute;
    left: 32px;
    top: 24px;
    margin: 0;
    color: #2c3e1f;
    font-weight: 400;
    font-size: 28px;
    letter-spacing: 1px;
    text-shadow: 0 2px 4px rgba(255, 255, 255, 0.5);
    z-index: 100;
  }
  
  #typedDisplay {
    position: absolute;
    left: 32px;
    bottom: 24px;
    background: rgba(255, 255, 255, 0.85);
    color: #2c3e1f;
    padding: 12px 24px;
    border-radius: 20px;
    border: 2px solid rgba(255, 255, 255, 0.9);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    font-size: 18px;
    font-family: 'Courier New', monospace;
    width: 600px;
    height: 80px;
    white-space: pre-wrap;
    word-wrap: break-word;
    letter-spacing: 2px;
    overflow-y: auto;
    z-index: 100;
  }
  
  #controls {
    position: absolute;
    right: 24px;
    top: 24px;
    display: flex;
    gap: 12px;
    z-index: 100;
  }
  
  button {
    background: rgba(255, 255, 255, 0.9);
    border: 2px solid rgba(255, 255, 255, 0.95);
    padding: 10px 20px;
    border-radius: 20px;
    font-weight: 600;
    font-size: 14px;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    color: #2c3e1f;
    transition: transform 0.2s, box-shadow 0.2s;
  }
  
  button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
  }
  
  button:active {
    transform: translateY(0);
  }
  
  /* Sun */
  .sun {
    position: fixed;
    top: 80px;
    right: 100px;
    width: 80px;
    height: 80px;
    background: radial-gradient(circle, #ffe66d 0%, #ffed4e 50%, transparent 70%);
    border-radius: 50%;
    opacity: 1;
    transition: top 1s ease, opacity 1s;
    pointer-events: none;
    box-shadow: 0 0 60px rgba(255, 230, 109, 0.6);
    z-index: 1;
  }
  
  .sun.setting {
    top: 120%;
    opacity: 0;
  }
  
  /* Birds */
  .bird {
    position: fixed;
    pointer-events: none;
    z-index: 5;
    animation: flyAcross linear infinite;
  }
  
  .bird svg {
    width: 40px;
    height: 25px;
  }
  
  @keyframes flyAcross {
    0% {
      transform: translateX(-100px) translateY(0px);
    }
    50% {
      transform: translateX(50vw) translateY(-20px);
    }
    100% {
      transform: translateX(calc(100vw + 100px)) translateY(0px);
    }
  }
  
  canvas {
    display: block;
  }
</style>
</head>
<body>
<!-- Grass layers -->
<div class="grass-layer"></div>
<script>
  // Generate detailed grass blades
  for (let i = 0; i < 150; i++) {
    const blade = document.createElement('div');
    blade.className = Math.random() > 0.7 ? 'grass-blade tall' : 'grass-blade';
    blade.style.left = Math.random() * 100 + '%';
    blade.style.height = (15 + Math.random() * 50) + 'px';
    blade.style.animationDelay = Math.random() * 3 + 's';
    blade.style.animationDuration = (2 + Math.random() * 3) + 's';
    document.body.appendChild(blade);
  }
</script>

<!-- Sun -->
<div class="sun" id="sun"></div>

<!-- Birds with SVG -->
<div class="bird" style="top: 15%; left: 20%; animation-duration: 25s; animation-delay: 0s;">
  <svg viewBox="0 0 40 25" xmlns="http://www.w3.org/2000/svg">
    <path d="M 5,15 Q 10,8 15,12 Q 20,5 25,12 Q 30,8 35,15" 
          fill="none" stroke="#2c3e1f" stroke-width="2" stroke-linecap="round" opacity="0.5"/>
  </svg>
</div>
<div class="bird" style="top: 25%; left: 60%; animation-duration: 30s; animation-delay: 5s;">
  <svg viewBox="0 0 40 25" xmlns="http://www.w3.org/2000/svg">
    <path d="M 5,15 Q 10,8 15,12 Q 20,5 25,12 Q 30,8 35,15" 
          fill="none" stroke="#2c3e1f" stroke-width="2" stroke-linecap="round" opacity="0.5"/>
  </svg>
</div>
<div class="bird" style="top: 10%; left: 80%; animation-duration: 28s; animation-delay: 10s;">
  <svg viewBox="0 0 40 25" xmlns="http://www.w3.org/2000/svg">
    <path d="M 8,18 Q 15,10 20,15" 
          fill="none" stroke="#2c3e1f" stroke-width="2" stroke-linecap="round" opacity="0.5"/>
  </svg>
</div>
<div class="bird" style="top: 20%; left: 40%; animation-duration: 32s; animation-delay: 15s;">
  <svg viewBox="0 0 40 25" xmlns="http://www.w3.org/2000/svg">
    <path d="M 5,15 Q 10,8 15,12 Q 20,5 25,12 Q 30,8 35,15" 
          fill="none" stroke="#2c3e1f" stroke-width="2" stroke-linecap="round" opacity="0.4"/>
  </svg>
</div>
<div class="bird" style="top: 12%; left: 10%; animation-duration: 27s; animation-delay: 20s;">
  <svg viewBox="0 0 40 25" xmlns="http://www.w3.org/2000/svg">
    <path d="M 8,18 Q 15,10 20,15" 
          fill="none" stroke="#2c3e1f" stroke-width="2" stroke-linecap="round" opacity="0.5"/>
  </svg>
</div>
<div class="bird" style="top: 18%; left: 70%; animation-duration: 29s; animation-delay: 8s;">
  <svg viewBox="0 0 40 25" xmlns="http://www.w3.org/2000/svg">
    <path d="M 5,12 Q 12,5 20,10 Q 28,5 35,12" 
          fill="none" stroke="#2c3e1f" stroke-width="2" stroke-linecap="round" opacity="0.4"/>
  </svg>
</div>

<div id="app">
  <h1>The Garden of Letters</h1>
  <div id="typedDisplay">Type to grow your garden...</div>
  <div id="controls">
    <button id="clearBtn">Clear Garden</button>
    <button id="exportBtn">Save Image</button>
  </div>
  <canvas id="visualCanvas"></canvas>
</div>

<!-- Rain sound (created with Web Audio API) -->
<script>
let audioContext = null;
let rainGain = null;
let rainOscillators = [];

function initAudio() {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    rainGain = audioContext.createGain();
    rainGain.gain.value = 0;
    rainGain.connect(audioContext.destination);
  }
}

function startRainSound() {
  initAudio();
  
  // Create multiple oscillators for rain-like white noise
  for (let i = 0; i < 3; i++) {
    const osc = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    osc.type = 'sawtooth';
    osc.frequency.value = 100 + Math.random() * 200;
    gainNode.gain.value = 0.03;
    
    osc.connect(gainNode);
    gainNode.connect(rainGain);
    osc.start();
    
    rainOscillators.push({ osc, gain: gainNode });
  }
  
  // Fade in
  rainGain.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 1);
}

function stopRainSound() {
  if (!rainGain || !audioContext) return;
  
  // Fade out
  rainGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1);
  
  setTimeout(() => {
    rainOscillators.forEach(({ osc }) => osc.stop());
    rainOscillators = [];
  }, 1100);
}
</script>

<script>
(() => {
  const canvas = document.getElementById('visualCanvas');
  const ctx = canvas.getContext('2d', { alpha: true });
  let W = canvas.width = window.innerWidth;
  let H = canvas.height = window.innerHeight;
  window.addEventListener('resize', () => { 
    W = canvas.width = window.innerWidth; 
    H = canvas.height = window.innerHeight; 
  });

  // STATE
  const trees = [];
  const flowers = [];
  let typed = '';
  const keyTimes = [];
  const MIN_HISTORY = 15;
  let currentStage = 1;
  let isRaining = false;
  let rainInterval = null;

  // Soft pastel colors for each vowel (based on reference images)
  const vowelColors = {
    a: '#f5c6d6',  // soft pink
    e: '#fffacd',  // soft cream/yellow
    i: '#c6d9f5',  // soft blue
    o: '#ffe4d9',  // soft peach
    u: '#dcc6f5'   // soft lavender
  };

  function random(min, max) { 
    return Math.random() * (max - min) + min; 
  }

  // Create a new tree
  function createTree(xPos) {
    const trunk = {
      x1: xPos,
      y1: H - 80,
      x2: xPos,
      y2: H - 200,
      angle: -Math.PI / 2,
      thickness: 12,
      segments: [],
      branches: []
    };
    
    trunk.segments = createTrunkSegments(trunk);
    return trunk;
  }

  function createTrunkSegments(branch) {
    const segments = [];
    const numSegments = 8;
    for (let i = 0; i <= numSegments; i++) {
      const t = i / numSegments;
      const x = branch.x1 + (branch.x2 - branch.x1) * t;
      const y = branch.y1 + (branch.y2 - branch.y1) * t;
      const thickness = branch.thickness * (1 - t * 0.3);
      segments.push({ x, y, thickness });
    }
    return segments;
  }

  // Start with first tree in center
  trees.push(createTree(W / 2));

  function getBranchColor(stage) {
    const colors = [
      [139, 111, 71],   // Stage 1: light brown
      [100, 80, 50],    // Stage 2: medium brown
      [70, 55, 35],     // Stage 3: dark brown
      [40, 30, 20]      // Stage 4: very dark brown (almost black)
    ];
    const c = colors[stage - 1];
    return `rgb(${c[0]}, ${c[1]}, ${c[2]})`;
  }

  function addBranch(tree, parent, stage) {
    const base = parent.angle || -Math.PI / 2;
    let angle = base + random(-Math.PI / 4, Math.PI / 4);
    const len = random(70, 120);
    const x1 = parent.segments[parent.segments.length - 1].x;
    const y1 = parent.segments[parent.segments.length - 1].y;
    
    const curvature = random(-0.3, 0.3);
    const midX = x1 + Math.cos(angle) * len * 0.5 + Math.cos(angle + Math.PI/2) * curvature * 30;
    const midY = y1 + Math.sin(angle) * len * 0.5 + Math.sin(angle + Math.PI/2) * curvature * 30;
    const x2 = x1 + Math.cos(angle) * len;
    const y2 = y1 + Math.sin(angle) * len;

    const thickness = 4 + stage * 1.5;
    
    const branch = {
      x1, y1, x2, y2, midX, midY, angle,
      thickness,
      parent,
      children: [],
      segments: [],
      tree: tree
    };
    
    const numSegments = 6;
    for (let i = 0; i <= numSegments; i++) {
      const t = i / numSegments;
      const x = (1-t)*(1-t)*x1 + 2*(1-t)*t*midX + t*t*x2;
      const y = (1-t)*(1-t)*y1 + 2*(1-t)*t*midY + t*t*y2;
      const segThickness = thickness * (1 - t * 0.4);
      branch.segments.push({ x, y, thickness: segThickness });
    }
    
    tree.branches.push(branch);
    if (parent.children) parent.children.push(branch);
    return branch;
  }

  function addFlower(branch, letter, stage) {
    const count = flowers.filter(f => f.char === letter).length;
    
    // Place flower ON the branch (between segments)
    const segmentIdx = Math.min(
      Math.floor(branch.segments.length * (0.3 + (count % 5) * 0.14)),
      branch.segments.length - 2
    );
    const segment = branch.segments[segmentIdx];
    
    // Small offset perpendicular to branch for natural look
    const branchAngle = branch.angle || 0;
    const offsetDist = 20 + (count % 3) * 8;
    const perpAngle = branchAngle + Math.PI / 2;
    const side = (count % 2 === 0) ? 1 : -1;
    
    const x = segment.x + Math.cos(perpAngle) * offsetDist * side;
    const y = segment.y + Math.sin(perpAngle) * offsetDist * side;

    const baseColor = vowelColors[letter.toLowerCase()] || '#ffccdd';
    
    let size, petalCount, layerCount, sharpness, color;
    
    switch(stage) {
      case 1: // Soft detailed rose
        size = 18;
        petalCount = 8;
        layerCount = 4;
        sharpness = 0;
        color = baseColor;
        break;
      case 2: // Fuller detailed bloom
        size = 22;
        petalCount = 10;
        layerCount = 5;
        sharpness = 0.15;
        color = brightenColor(baseColor, 8);
        break;
      case 3: // More complex flower
        size = 28;
        petalCount = 12;
        layerCount = 4;
        sharpness = 0.5;
        color = brightenColor(baseColor, 15);
        break;
      case 4: // Large detailed spiky flower
        size = 34;
        petalCount = 14;
        layerCount = 3;
        sharpness = 0.85;
        const brightColors = {
          a: '#ffa6c9',  // brighter pink
          e: '#fffaaa',  // brighter yellow
          i: '#a6c9ff',  // brighter blue
          o: '#ffc9a6',  // brighter peach
          u: '#c9a6ff'   // brighter lavender
        };
        color = brightColors[letter.toLowerCase()] || brightenColor(baseColor, 25);
        break;
    }

    const flower = {
      x, y,
      color,
      char: letter,
      stage,
      size,
      petalCount,
      layerCount,
      sharpness,
      createdAt: performance.now(),
      floatPhase: random(0, Math.PI * 2),
      rotationOffset: random(0, Math.PI * 2)
    };
    
    flowers.push(flower);
  }

  function brightenColor(hex, percent) {
    const num = parseInt(hex.replace('#', ''), 16);
    const amt = Math.round(2.55 * percent);
    const R = Math.min(255, (num >> 16) + amt);
    const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
    const B = Math.min(255, (num & 0x0000FF) + amt);
    return `rgb(${R}, ${G}, ${B})`;
  }

  function drawFlower(f, t) {
    ctx.save();
    
    const age = (t - f.createdAt) / 1000;
    const fx = f.x + Math.cos(t / 1200 + f.floatPhase) * 2;
    const fy = f.y + Math.sin(t / 1000 + f.floatPhase) * 3;
    
    ctx.translate(fx, fy);
    ctx.rotate(t / 8000 + f.rotationOffset);
    
    const scale = Math.min(1, age * 3);
    ctx.scale(scale, scale);
    
    if (f.stage === 4) {
      ctx.shadowBlur = 15;
      ctx.shadowColor = f.color;
    } else {
      ctx.shadowBlur = 6;
      ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
    }
    
    // Draw petal layers - more detailed and natural
    for (let layer = f.layerCount - 1; layer >= 0; layer--) {
      const layerSize = 1 - (layer * 0.12);
      const layerRotation = (layer * Math.PI / f.petalCount) * 0.6;
      
      ctx.save();
      ctx.rotate(layerRotation);
      ctx.globalAlpha = 0.85 - layer * 0.08;
      
      const angleStep = (Math.PI * 2) / f.petalCount;
      for (let i = 0; i < f.petalCount; i++) {
        const angle = angleStep * i;
        ctx.save();
        ctx.rotate(angle);
        
        ctx.beginPath();
        
        if (f.sharpness > 0.4) {
          // Detailed spiky/pointed petals
          const tipDist = f.size * layerSize * 2.4;
          const baseWidth = f.size * layerSize * (0.6 - f.sharpness * 0.25);
          const controlDist = f.size * layerSize * 1.4;
          
          // Create more natural curves
          ctx.moveTo(0, -f.size * layerSize * 0.2);
          ctx.bezierCurveTo(
            -baseWidth * 0.7, -controlDist * 0.5,
            -baseWidth * 0.4, -controlDist * 1.2,
            0, -tipDist
          );
          ctx.bezierCurveTo(
            baseWidth * 0.4, -controlDist * 1.2,
            baseWidth * 0.7, -controlDist * 0.5,
            0, -f.size * layerSize * 0.2
          );
          ctx.closePath();
        } else {
          // Soft, detailed rose-like petals
          const petalLength = f.size * layerSize * 1.8;
          const petalWidth = f.size * layerSize * 1.2;
          const centerY = -f.size * layerSize * 1.0;
          
          // Natural rose petal shape with ruffles
          ctx.moveTo(0, -f.size * layerSize * 0.15);
          ctx.bezierCurveTo(
            -petalWidth * 0.6, centerY - petalLength * 0.2,
            -petalWidth * 0.5, centerY - petalLength * 0.6,
            -petalWidth * 0.2, centerY - petalLength * 0.85
          );
          ctx.bezierCurveTo(
            -petalWidth * 0.1, centerY - petalLength * 0.95,
            petalWidth * 0.1, centerY - petalLength * 0.95,
            petalWidth * 0.2, centerY - petalLength * 0.85
          );
          ctx.bezierCurveTo(
            petalWidth * 0.5, centerY - petalLength * 0.6,
            petalWidth * 0.6, centerY - petalLength * 0.2,
            0, -f.size * layerSize * 0.15
          );
          ctx.closePath();
        }
        
        // More detailed gradient for depth
        const gradient = ctx.createRadialGradient(0, -f.size * layerSize * 0.6, 0, 0, -f.size * layerSize * 1.2, f.size * layerSize * 1.5);
        const lightAmount = 20 + layer * 5;
        const darkAmount = layer * 10 + 8;
        gradient.addColorStop(0, brightenColor(f.color, lightAmount));
        gradient.addColorStop(0.5, f.color);
        gradient.addColorStop(1, brightenColor(f.color, -darkAmount));
        
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Add subtle petal edge highlight for realism
        if (f.stage <= 2) {
          ctx.strokeStyle = brightenColor(f.color, 10);
          ctx.lineWidth = 0.5;
          ctx.globalAlpha = 0.3;
          ctx.stroke();
        }
        
        ctx.restore();
      }
      
      ctx.restore();
    }
    
    // Detailed center with multiple layers
    const centerSize = f.size * 0.55;
    
    // Outer center ring
    ctx.beginPath();
    ctx.arc(0, 0, centerSize, 0, Math.PI * 2);
    const centerGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, centerSize);
    centerGradient.addColorStop(0, brightenColor(f.color, 30));
    centerGradient.addColorStop(0.6, f.color);
    centerGradient.addColorStop(1, brightenColor(f.color, -15));
    ctx.fillStyle = centerGradient;
    ctx.globalAlpha = 0.9;
    ctx.fill();
    
    // Inner center
    ctx.beginPath();
    ctx.arc(0, 0, centerSize * 0.5, 0, Math.PI * 2);
    const innerGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, centerSize * 0.5);
    innerGradient.addColorStop(0, '#fffef5');
    innerGradient.addColorStop(1, brightenColor(f.color, 10));
    ctx.fillStyle = innerGradient;
    ctx.globalAlpha = 0.95;
    ctx.fill();
    
    // Detailed stamens for all stages
    ctx.globalAlpha = 0.8;
    const stamenCount = f.stage <= 2 ? 12 : 16;
    const stamenRadius = centerSize * (f.stage <= 2 ? 0.7 : 0.75);
    
    for (let i = 0; i < stamenCount; i++) {
      const angle = (Math.PI * 2 * i) / stamenCount;
      const sx = Math.cos(angle) * stamenRadius;
      const sy = Math.sin(angle) * stamenRadius;
      
      // Stamen stem
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(sx, sy);
      ctx.strokeStyle = brightenColor(f.color, -25);
      ctx.lineWidth = 0.8;
      ctx.stroke();
      
      // Stamen tip
      ctx.beginPath();
      ctx.arc(sx, sy, 1.8, 0, Math.PI * 2);
      ctx.fillStyle = brightenColor(f.color, -30);
      ctx.fill();
    }
    
    ctx.restore();
  }

  function drawBranch(b) {
    if (!b.segments || b.segments.length < 2) return;
    
    const color = getBranchColor(currentStage);
    
    for (let i = 0; i < b.segments.length - 1; i++) {
      const s1 = b.segments[i];
      const s2 = b.segments[i + 1];
      
      ctx.strokeStyle = color;
      ctx.lineWidth = s1.thickness;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      
      ctx.beginPath();
      ctx.moveTo(s1.x, s1.y);
      ctx.lineTo(s2.x, s2.y);
      ctx.stroke();
      
      if (i % 2 === 0 && s1.thickness > 6) {
        ctx.strokeStyle = brightenColor(color, -15);
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(s1.x - 2, s1.y);
        ctx.lineTo(s1.x + 2, s1.y + 3);
        ctx.stroke();
      }
    }
  }

  function computeStage() {
    if (keyTimes.length < MIN_HISTORY) return 1;
    
    const recent = keyTimes.slice(-MIN_HISTORY);
    const diffs = [];
    for (let i = 1; i < recent.length; i++) {
      diffs.push(recent[i] - recent[i - 1]);
    }
    
    const avgDelay = diffs.reduce((a, b) => a + b, 0) / diffs.length;
    const keysPerSecond = 1000 / avgDelay;
    
    // Check for rain (very fast typing)
    if (keysPerSecond > 7) {
      startRain();
    } else if (keysPerSecond < 4) {
      stopRain();
    }
    
    if (keysPerSecond < 2) return 1;
    if (keysPerSecond < 3.5) return 2;
    if (keysPerSecond < 5.5) return 3;
    return 4;
  }

  function startRain() {
    if (isRaining) return;
    isRaining = true;
    document.getElementById('sun').classList.add('setting');
    startRainSound();
    
    // Create rain effect
    rainInterval = setInterval(() => {
      if (!isRaining) {
        clearInterval(rainInterval);
        return;
      }
      
      for (let i = 0; i < 3; i++) {
        const drop = document.createElement('div');
        drop.className = 'raindrop';
        drop.style.left = Math.random() * 100 + '%';
        drop.style.top = -20 + 'px';
        drop.style.animationDuration = (0.5 + Math.random() * 0.3) + 's';
        document.body.appendChild(drop);
        
        setTimeout(() => drop.remove(), 1000);
      }
    }, 50);
  }

  function stopRain() {
    if (!isRaining) return;
    isRaining = false;
    document.getElementById('sun').classList.remove('setting');
    stopRainSound();
    
    if (rainInterval) {
      clearInterval(rainInterval);
      rainInterval = null;
    }
  }

  function updateTypedDisplay() {
    document.getElementById('typedDisplay').innerText = typed || 'Type to grow your garden...';
  }

  // RENDER LOOP
  function render(t) {
    ctx.clearRect(0, 0, W, H);
    
    // Draw all trees
    trees.forEach(tree => {
      drawBranch(tree);
      tree.branches.forEach(b => drawBranch(b));
    });
    
    // Draw flowers
    flowers.forEach(f => drawFlower(f, t));
    
    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);

  // TYPING HANDLER
  document.addEventListener('keydown', (e) => {
    // Handle spacebar for new tree
    if (e.key === ' ') {
      e.preventDefault();
      
      // Position new tree next to existing trees
      let newX;
      if (trees.length === 1) {
        // Second tree: place to the right of center
        newX = W / 2 + 200;
      } else if (trees.length === 2) {
        // Third tree: place to the left of center
        newX = W / 2 - 200;
      } else if (trees.length === 3) {
        // Fourth tree: further right
        newX = W / 2 + 400;
      } else if (trees.length === 4) {
        // Fifth tree: further left
        newX = W / 2 - 400;
      } else {
        // Additional trees alternate sides
        const side = (trees.length % 2 === 0) ? 1 : -1;
        const distance = 200 * Math.ceil(trees.length / 2);
        newX = W / 2 + (distance * side);
      }
      
      const newTree = createTree(newX);
      trees.push(newTree);
      typed += ' ';
      updateTypedDisplay();
      return;
    }
    
    if (e.key.length === 1 && /[a-z]/i.test(e.key)) {
      const now = performance.now();
      keyTimes.push(now);
      
      if (keyTimes.length >= MIN_HISTORY) {
        currentStage = computeStage();
      }

      const letter = e.key;
      const isVowel = /[aeiou]/i.test(letter);

      typed += letter;
      updateTypedDisplay();

      if (isVowel) {
        // VOWELS create flowers on branches
        const currentTree = trees[trees.length - 1];
        const allBranches = [currentTree, ...currentTree.branches];
        if (allBranches.length > 0) {
          const targetBranch = allBranches[Math.floor(Math.random() * allBranches.length)];
          addFlower(targetBranch, letter, currentStage);
        }
      } else {
        // CONSONANTS grow branches
        const currentTree = trees[trees.length - 1];
        const upperBranches = currentTree.branches.filter(b => b.segments && b.segments[b.segments.length - 1].y < H - 100);
        const parent = upperBranches.length > 0 
          ? upperBranches[Math.floor(Math.random() * upperBranches.length)]
          : currentTree;
        
        addBranch(currentTree, parent, currentStage);
      }
    }
  });

  // CLEAR with falling animation
  document.getElementById('clearBtn').addEventListener('click', () => {
    const fallInterval = setInterval(() => {
      trees.forEach(tree => {
        if (tree.segments) tree.segments.forEach(s => s.y += 15);
        tree.branches.forEach(b => {
          if (b.segments) b.segments.forEach(s => s.y += 15);
        });
      });
      flowers.forEach(f => f.y += 15);
      
      if (trees[0] && trees[0].segments[0].y > H + 150) {
        clearInterval(fallInterval);
        trees.length = 0;
        flowers.length = 0;
        typed = '';
        keyTimes.length = 0;
        currentStage = 1;
        stopRain();
        
        trees.push(createTree(W / 2));
        updateTypedDisplay();
      }
    }, 30);
  });

  // EXPORT
  document.getElementById('exportBtn').addEventListener('click', () => {
    const url = canvas.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    a.download = 'garden-of-letters.png';
    a.click();
  });

  // Seed initial branches
  setTimeout(() => {
    for (let i = 0; i < 3; i++) {
      setTimeout(() => {
        const tree = trees[0];
        const parent = tree.branches.length > 0 
          ? tree.branches[Math.floor(Math.random() * tree.branches.length)]
          : tree;
        addBranch(tree, parent, 1);
      }, i * 200);
    }
  }, 300);

})();
</script>
</body>
</html>
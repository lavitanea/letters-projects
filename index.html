<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualising Words</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: #e8f4f8;
            overflow: hidden;
            height: 100vh;
            transition: background-color 0.3s ease;
        }

        #title {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            color: #8b7355;
            letter-spacing: 3px;
            z-index: 1000;
            text-transform: lowercase;
            font-weight: 300;
        }

        #speed-indicator {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 18px;
            color: #6b5d52;
            letter-spacing: 2px;
            z-index: 1000;
            text-transform: lowercase;
            font-weight: 300;
            padding: 8px 20px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 20px;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        #clear-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            padding: 12px 28px;
            background: #d4a5a5;
            border: none;
            border-radius: 25px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s;
            letter-spacing: 1px;
            text-transform: lowercase;
        }

        #clear-btn:hover {
            background: #c49090;
            transform: scale(1.05);
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .flower {
            position: absolute;
            transform-origin: center;
            transition: opacity 0.8s;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% {
                transform: translate(0, 0) rotate(0deg);
            }
            25% {
                transform: translate(3px, -5px) rotate(2deg);
            }
            50% {
                transform: translate(-2px, -8px) rotate(-2deg);
            }
            75% {
                transform: translate(-4px, -3px) rotate(1deg);
            }
        }

        .falling {
            animation: fall 2s forwards !important;
        }

        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="title">visualising words</div>
    <div id="speed-indicator">stage 1: very slow</div>
    <svg id="canvas"></svg>
    <button id="clear-btn">clear</button>

    <script>
        const canvas = document.getElementById('canvas');
        const clearBtn = document.getElementById('clear-btn');
        const speedIndicator = document.getElementById('speed-indicator');
        
        const vowels = ['a', 'e', 'i', 'o', 'u', 'y'];
        const consonants = 'bcdfghjklmnpqrstvwxz'.split('');
        
        // Flower colors for each vowel with progressive vibrancy
        const vowelColors = {
            'a': { 
                stage1: '#ffe8ea', stage2: '#ffd4d8', stage3: '#ffb3ba', 
                stage4: '#ff8fa3', stage5: '#ff6b7a' 
            },
            'e': { 
                stage1: '#fff0f5', stage2: '#ffe0eb', stage3: '#ffc9de', 
                stage4: '#ffadd2', stage5: '#ff8fb8' 
            },
            'i': { 
                stage1: '#e8f4ff', stage2: '#d4e7ff', stage3: '#bae1ff', 
                stage4: '#95d5ff', stage5: '#6bb8ff' 
            },
            'o': { 
                stage1: '#f5e8ff', stage2: '#ebd4ff', stage3: '#e0b3ff', 
                stage4: '#d199ff', stage5: '#c76bff' 
            },
            'u': { 
                stage1: '#ede8ff', stage2: '#dcd4ff', stage3: '#c9b3ff', 
                stage4: '#b399ff', stage5: '#9d6bff' 
            },
            'y': { 
                stage1: '#f3edff', stage2: '#e8deff', stage3: '#d4c5f9', 
                stage4: '#c0aef5', stage5: '#b89dff' 
            }
        };

        // Speed stage labels
        const speedStages = [
            { name: 'stage 1: very slow', min: 0, max: 0.2 },
            { name: 'stage 2: slow', min: 0.2, max: 0.4 },
            { name: 'stage 3: medium', min: 0.4, max: 0.6 },
            { name: 'stage 4: fast', min: 0.6, max: 0.8 },
            { name: 'stage 5: very fast', min: 0.8, max: 1.0 }
        ];

        let branches = [];
        let flowers = [];
        let lastTypeTime = Date.now();
        let typeSpeed = 0;
        let currentStage = 1;
        let mainBranches = [];
        let flowerPositions = [];

        function calculateTypeSpeed() {
            const now = Date.now();
            const timeDiff = now - lastTypeTime;
            typeSpeed = Math.max(0, Math.min(1, 1 - (timeDiff / 800)));
            lastTypeTime = now;
            updateSpeedStage();
            updateBackground();
        }

        function updateSpeedStage() {
            for (let i = 0; i < speedStages.length; i++) {
                if (typeSpeed >= speedStages[i].min && typeSpeed <= speedStages[i].max) {
                    if (currentStage !== i + 1) {
                        currentStage = i + 1;
                        speedIndicator.textContent = speedStages[i].name;
                        speedIndicator.style.transform = 'translateX(-50%) scale(1.1)';
                        setTimeout(() => {
                            speedIndicator.style.transform = 'translateX(-50%) scale(1)';
                        }, 200);
                    }
                    break;
                }
            }
        }

        function updateBackground() {
            // Background transitions from light blue to black
            const lightness = Math.floor(232 - (typeSpeed * 232)); // 232 to 0
            const blue = Math.floor(248 - (typeSpeed * 248)); // 248 to 0
            document.body.style.backgroundColor = `rgb(${lightness}, ${lightness + Math.floor((blue - lightness) * (1 - typeSpeed))}, ${blue})`;
        }

        function initMainBranches() {
            if (mainBranches.length > 0) return;
            
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            
            const corners = [
                { x: 80, y: 120, angle: Math.atan2(centerY - 120, centerX - 80) },
                { x: window.innerWidth - 80, y: 120, angle: Math.atan2(centerY - 120, centerX - (window.innerWidth - 80)) },
                { x: window.innerWidth - 80, y: window.innerHeight - 80, angle: Math.atan2(centerY - (window.innerHeight - 80), centerX - (window.innerWidth - 80)) },
                { x: 80, y: window.innerHeight - 80, angle: Math.atan2(centerY - (window.innerHeight - 80), centerX - 80) }
            ];
            
            corners.forEach((corner) => {
                const distance = Math.hypot(centerX - corner.x, centerY - corner.y);
                const length = distance * 0.6;
                const endX = corner.x + Math.cos(corner.angle) * length;
                const endY = corner.y + Math.sin(corner.angle) * length;
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const controlX = corner.x + Math.cos(corner.angle) * length * 0.5;
                const controlY = corner.y + Math.sin(corner.angle) * length * 0.5;
                
                path.setAttribute('d', `M ${corner.x} ${corner.y} Q ${controlX} ${controlY} ${endX} ${endY}`);
                path.setAttribute('stroke', '#a89080');
                path.setAttribute('stroke-width', '8');
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke-linecap', 'butt');
                path.setAttribute('opacity', '0.6');
                
                canvas.appendChild(path);
                
                mainBranches.push({
                    element: path,
                    startX: corner.x,
                    startY: corner.y,
                    endX: endX,
                    endY: endY,
                    angle: corner.angle,
                    length: length
                });
            });
        }

        function getRandomPointOnMainBranch(branchIndex) {
            const branch = mainBranches[branchIndex];
            const t = 0.3 + Math.random() * 0.5;
            
            const x = branch.startX + (branch.endX - branch.startX) * t;
            const y = branch.startY + (branch.endY - branch.startY) * t;
            
            return { x, y, angle: branch.angle };
        }

        function createBranch(startX, startY, baseAngle, speed) {
            const angleVariation = (Math.random() - 0.5) * Math.PI / 2;
            const angle = baseAngle + angleVariation;
            const length = 30 + Math.random() * 30 + speed * 40;
            
            const endX = startX + Math.cos(angle) * length;
            const endY = startY + Math.sin(angle) * length;
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            // Sharp or curved based on speed
            if (speed > 0.5) {
                path.setAttribute('d', `M ${startX} ${startY} L ${endX} ${endY}`);
            } else {
                const controlX = startX + Math.cos(angle + 0.2) * length * 0.6;
                const controlY = startY + Math.sin(angle + 0.2) * length * 0.6;
                path.setAttribute('d', `M ${startX} ${startY} Q ${controlX} ${controlY} ${endX} ${endY}`);
            }
            
            // Color and thickness based on speed
            let color, strokeWidth, opacity;
            
            if (speed > 0.5) {
                // Fast: black, thick, solid
                const darkness = Math.floor((1 - speed) * 50);
                color = `rgb(${darkness}, ${darkness}, ${darkness})`;
                strokeWidth = 6 + speed * 8;
                opacity = 1;
            } else {
                // Slow: light brown, thinner, transparent
                color = '#c4a895';
                strokeWidth = 3 + speed * 3;
                opacity = 0.3 + speed * 0.3;
            }
            
            path.setAttribute('stroke', color);
            path.setAttribute('stroke-width', strokeWidth);
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke-linecap', 'butt'); // Sharp ends
            path.setAttribute('opacity', opacity);
            
            canvas.appendChild(path);
            branches.push({ element: path, endX, endY, angle });
            
            return { x: endX, y: endY };
        }

        function checkOverlap(x, y, size) {
            let overlapCount = 0;
            const checkRadius = size * 1.5;
            
            for (let pos of flowerPositions) {
                const distance = Math.hypot(x - pos.x, y - pos.y);
                if (distance < (checkRadius + pos.size)) {
                    overlapCount++;
                }
            }
            
            return overlapCount;
        }

        function findNonOverlappingPosition(baseX, baseY, size, maxAttempts = 20) {
            for (let i = 0; i < maxAttempts; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 40 + Math.random() * 60;
                const x = baseX + Math.cos(angle) * distance;
                const y = baseY + Math.sin(angle) * distance;
                
                if (x < 50 || x > window.innerWidth - 50 || y < 100 || y > window.innerHeight - 50) {
                    continue;
                }
                
                const overlaps = checkOverlap(x, y, size);
                const maxAllowedOverlaps = Math.floor(flowerPositions.length * 0.3);
                
                if (overlaps <= maxAllowedOverlaps) {
                    return { x, y };
                }
            }
            return { x: baseX, y: baseY };
        }

        function createFlower(x, y, vowel, speed) {
            const colors = vowelColors[vowel];
            const petalCount = 6;
            
            // Determine stage (1-5) based on speed
            let stage;
            if (speed < 0.2) stage = 1;
            else if (speed < 0.4) stage = 2;
            else if (speed < 0.6) stage = 3;
            else if (speed < 0.8) stage = 4;
            else stage = 5;
            
            // Get color for stage
            const color = colors[`stage${stage}`];
            
            // Size progression: stage 1 smallest, stage 5 largest
            const baseSizes = [12, 18, 25, 35, 50];
            const size = baseSizes[stage - 1];
            
            // Opacity progression
            const opacities = [0.3, 0.45, 0.65, 0.85, 1.0];
            const opacity = opacities[stage - 1];
            
            // Check for overlap and adjust position
            const position = findNonOverlappingPosition(x, y, size);
            x = position.x;
            y = position.y;
            
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('class', 'flower');
            
            // Create petals based on stage
            for (let i = 0; i < petalCount; i++) {
                const angle = (i * 360 / petalCount) * Math.PI / 180;
                
                if (stage === 1 || stage === 2) {
                    // STAGES 1-2: Very round, friendly, soft petals (circles)
                    const petal = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    const petalSize = size * (stage === 1 ? 0.5 : 0.6);
                    const petalDistance = size * (stage === 1 ? 0.45 : 0.5);
                    
                    petal.setAttribute('cx', x + Math.cos(angle) * petalDistance);
                    petal.setAttribute('cy', y + Math.sin(angle) * petalDistance);
                    petal.setAttribute('r', petalSize);
                    petal.setAttribute('fill', color);
                    petal.setAttribute('opacity', opacity);
                    
                    group.appendChild(petal);
                    
                } else if (stage === 3) {
                    // STAGE 3: Rounded ellipse petals
                    const petal = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
                    const rx = size * 0.45;
                    const ry = size * 0.75;
                    const petalDistance = size * 0.4;
                    
                    petal.setAttribute('cx', x + Math.cos(angle) * petalDistance);
                    petal.setAttribute('cy', y + Math.sin(angle) * petalDistance);
                    petal.setAttribute('rx', rx);
                    petal.setAttribute('ry', ry);
                    petal.setAttribute('fill', color);
                    petal.setAttribute('opacity', opacity);
                    petal.setAttribute('transform', `rotate(${(i * 360 / petalCount) + 90} ${x + Math.cos(angle) * petalDistance} ${y + Math.sin(angle) * petalDistance})`);
                    
                    group.appendChild(petal);
                    
                } else if (stage === 4) {
                    // STAGE 4: Longer, more pointed ellipse
                    const petal = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
                    const rx = size * 0.3;
                    const ry = size * 1.1;
                    const petalDistance = size * 0.35;
                    
                    petal.setAttribute('cx', x + Math.cos(angle) * petalDistance);
                    petal.setAttribute('cy', y + Math.sin(angle) * petalDistance);
                    petal.setAttribute('rx', rx);
                    petal.setAttribute('ry', ry);
                    petal.setAttribute('fill', color);
                    petal.setAttribute('opacity', opacity);
                    petal.setAttribute('transform', `rotate(${(i * 360 / petalCount) + 90} ${x + Math.cos(angle) * petalDistance} ${y + Math.sin(angle) * petalDistance})`);
                    
                    group.appendChild(petal);
                    
                } else {
                    // STAGE 5: Sharp triangular petals, longest and sharpest
                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    
                    const length = size * 1.8;
                    const width = size * 0.2;
                    const tipX = x + Math.cos(angle) * length;
                    const tipY = y + Math.sin(angle) * length;
                    
                    const perpAngle = angle + Math.PI / 2;
                    const baseLeft = {
                        x: x + Math.cos(perpAngle) * width,
                        y: y + Math.sin(perpAngle) * width
                    };
                    const baseRight = {
                        x: x - Math.cos(perpAngle) * width,
                        y: y - Math.sin(perpAngle) * width
                    };
                    
                    polygon.setAttribute('points', `${tipX},${tipY} ${baseLeft.x},${baseLeft.y} ${baseRight.x},${baseRight.y}`);
                    polygon.setAttribute('fill', color);
                    polygon.setAttribute('opacity', opacity);
                    
                    group.appendChild(polygon);
                }
            }
            
            // Center
            const centerSize = size * 0.3;
            const center = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            center.setAttribute('cx', x);
            center.setAttribute('cy', y);
            center.setAttribute('r', centerSize);
            center.setAttribute('fill', stage <= 2 ? '#ffd966' : '#ffb347');
            center.setAttribute('opacity', opacity);
            group.appendChild(center);
            
            // Add random animation delay for varied floating
            group.style.animationDelay = Math.random() * 2 + 's';
            group.style.animationDuration = (2.5 + Math.random() * 1.5) + 's';
            
            canvas.appendChild(group);
            flowers.push(group);
            flowerPositions.push({ x, y, size });
        }

        function handleKeyPress(e) {
            const key = e.key.toLowerCase();
            
            if (key.length !== 1 || !/[a-z]/.test(key)) return;
            
            calculateTypeSpeed();
            
            if (mainBranches.length === 0) {
                initMainBranches();
            }
            
            if (vowels.includes(key)) {
                let x, y;
                
                if (Math.random() > 0.3 && mainBranches.length > 0) {
                    const branchIndex = Math.floor(Math.random() * 4);
                    const point = getRandomPointOnMainBranch(branchIndex);
                    
                    const distance = typeSpeed < 0.5 ? 70 + Math.random() * 50 : 30 + Math.random() * 40;
                    const offsetAngle = Math.random() * Math.PI * 2;
                    
                    x = point.x + Math.cos(offsetAngle) * distance;
                    y = point.y + Math.sin(offsetAngle) * distance;
                } else {
                    x = 100 + Math.random() * (window.innerWidth - 200);
                    y = 150 + Math.random() * (window.innerHeight - 200);
                }
                
                createFlower(x, y, key, typeSpeed);
            } else if (consonants.includes(key)) {
                let startX, startY, baseAngle;
                
                if (branches.length === 0 || Math.random() > 0.7) {
                    const branchIndex = Math.floor(Math.random() * 4);
                    const point = getRandomPointOnMainBranch(branchIndex);
                    startX = point.x;
                    startY = point.y;
                    baseAngle = point.angle;
                } else {
                    const lastBranch = branches[branches.length - 1];
                    startX = lastBranch.endX;
                    startY = lastBranch.endY;
                    baseAngle = lastBranch.angle;
                }
                
                createBranch(startX, startY, baseAngle, typeSpeed);
            }
        }

        function clearCanvas() {
            mainBranches.forEach(branch => {
                branch.element.classList.add('falling');
            });
            
            branches.forEach(branch => {
                branch.element.classList.add('falling');
            });
            
            flowers.forEach(flower => {
                flower.classList.add('falling');
            });
            
            setTimeout(() => {
                mainBranches.forEach(branch => branch.element.remove());
                branches.forEach(branch => branch.element.remove());
                flowers.forEach(flower => flower.remove());
                mainBranches = [];
                branches = [];
                flowers = [];
                flowerPositions = [];
                document.body.style.backgroundColor = '#e8f4f8';
                currentStage = 1;
                speedIndicator.textContent = 'stage 1: very slow';
            }, 2000);
        }

        document.addEventListener('keypress', handleKeyPress);
        clearBtn.addEventListener('click', clearCanvas);

        function resizeCanvas() {
            canvas.setAttribute('width', window.innerWidth);
            canvas.setAttribute('height', window.innerHeight);
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>